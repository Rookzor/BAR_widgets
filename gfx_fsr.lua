if gl.CreateShader == nil then
	return
end

function widget:GetInfo()
	return {
		name	  = "FidelityFX Supersampling Resolution (FSR) with FXAA",
		desc	  = "Port of AMD FSR, slighlty blended with Nvidia's FXAA 2.0. Custom params in file to change sharpness. NOTE: Enabling this widget will auto disable CAS.",
		author	  = "Errrrrrr",
		version	  = "1.0",
		date 	  = "July, 2023",
		layer	  = 2000-1,
		license   = "GNU GPL, v2 or later",
		enabled   = true,
		handler   = true,
	}
end

-----------------------------------------------------------------
-- This is an experimental postprocessing widget that uses
-- FidelityFX Super Resolution (FSR) with FXAA 2.0 blended in
-- 
-- The aim of this widget is to provide a middle ground between 
-- the default CAS and base game rendering, and FXAA allows for
-- slightly less MSAA to be used in settings, possibly improving
-- performance.
--
-- NOTE: This widget will auto-disable the CAS widget when it is
-- enabled.
-----------------------------------------------------------------

-----------------------------------------------------------------
-- Params
-----------------------------------------------------------------
local SHARPNESS = 0.1	-- 0.0 - 1.0 LOWER IS MORE SHARPNESS, default 0.1
local blend_factor = 0.8	-- 0.0 - 1.0 LOWER IS MORE FXAA, HIGHER IS MORE FSR, default 0.8




-----------------------------------------------------------------
-- Constants
-----------------------------------------------------------------

local GL_RGBA8 = 0x8058
local version = 1.0

-- get screen sizes
local vsx, vsy = Spring.GetViewGeometry()

-----------------------------------------------------------------
-- Lua Shortcuts
-----------------------------------------------------------------

local glTexture		 = gl.Texture
local glBlending	 = gl.Blending
local glCopyToTexture   = gl.CopyToTexture

-----------------------------------------------------------------
-- File path Constants
-----------------------------------------------------------------

local luaShaderDir = "LuaUI/Widgets/Include/"

-----------------------------------------------------------------
-- Shader Sources
-----------------------------------------------------------------

local vsFSR = [[
#version 330
// full screen triangle

const vec2 vertices[3] = vec2[3](
	vec2(-1.0, -1.0),
	vec2( 3.0, -1.0),
	vec2(-1.0,  3.0)
);

void main()
{
	gl_Position = vec4(vertices[gl_VertexID], 0.0, 1.0);
}
]]

local fsFSR = [[
#version 330
#line 20058

uniform sampler2D screenCopyTex;
uniform float sharpness;
uniform float blend_factor;
uniform vec2 u_inverseViewportSize;
#define FXAA_REDUCE_MIN   (1.0/ 128.0)
#define FXAA_REDUCE_MUL   (1.0 / 8.0)
#define FXAA_SPAN_MAX     3.0

#if 0
	#define TEXEL_FETCH_OFFSET(t, c, l, o) texelFetch(t, c + o, l)
#else
	#define TEXEL_FETCH_OFFSET texelFetchOffset
#endif

out vec4 fragColor;

// FSR code ported from https://www.shadertoy.com/view/stXSWB
/***** RCAS *****/
#define FSR_RCAS_LIMIT (0.25-(1.0/16.0))
#define FSR_RCAS_DENOISE

// Input callback prototypes that need to be implemented by calling shader
vec4 FsrRcasLoadF(vec2 p);
//------------------------------------------------------------------------------------------------------------------------------
void FsrRcasCon(
    out float con,
    // The scale is {0.0 := maximum, to N>0, where N is the number of stops (halving) of the reduction of sharpness}.
    float sharpness
){
    // Transform from stops to linear value.
    con = exp2(-sharpness);
}

vec3 FsrRcasF(ivec2 tc, float con)
{
    // Constant generated by RcasSetup().
    // Algorithm uses minimal 3x3 pixel neighborhood.
    //    b 
    //  d e f
    //    h

    vec3 b = TEXEL_FETCH_OFFSET(screenCopyTex, tc, 0, ivec2( 0, -1)).rgb;
	vec3 d = TEXEL_FETCH_OFFSET(screenCopyTex, tc, 0, ivec2(-1,  0)).rgb;
	vec3 e = TEXEL_FETCH_OFFSET(screenCopyTex, tc, 0, ivec2( 0,  0)).rgb;
	vec3 f = TEXEL_FETCH_OFFSET(screenCopyTex, tc, 0, ivec2( 1,  0)).rgb;
	vec3 g = TEXEL_FETCH_OFFSET(screenCopyTex, tc, 0, ivec2(-1,  1)).rgb;
    vec3 h = TEXEL_FETCH_OFFSET(screenCopyTex, tc, 0, ivec2( 0,  1)).rgb;


    // Luma times 2.
    float bL = b.g + .5 * (b.b + b.r);
    float dL = d.g + .5 * (d.b + d.r);
    float eL = e.g + .5 * (e.b + e.r);
    float fL = f.g + .5 * (f.b + f.r);
    float hL = h.g + .5 * (h.b + h.r);
    // Noise detection.
    float nz = .25 * (bL + dL + fL + hL) - eL;
    nz=clamp(
        abs(nz)
        /(
            max(max(bL,dL),max(eL,max(fL,hL)))
            -min(min(bL,dL),min(eL,min(fL,hL)))
        ),
        0., 1.
    );
    nz=1.-.5*nz;
    // Min and max of ring.
    vec3 mn4 = min(b, min(f, h));
    vec3 mx4 = max(b, max(f, h));
    // Immediate constants for peak range.
    vec2 peakC = vec2(1., -4.);
    // Limiters, these need to be high precision RCPs.
    vec3 hitMin = mn4 / (4. * mx4);
    vec3 hitMax = (peakC.x - mx4) / (4.* mn4 + peakC.y);
    vec3 lobeRGB = max(-hitMin, hitMax);
    float lobe = max(
        -FSR_RCAS_LIMIT,
        min(max(lobeRGB.r, max(lobeRGB.g, lobeRGB.b)), 0.)
    )*con;
    // Apply noise removal.
    #ifdef FSR_RCAS_DENOISE
    lobe *= nz;
    #endif
    // Resolve, which needs the medium precision rcp approximation to avoid visible tonality changes.
    return (lobe * (b + d + h + f) + e) / (4. * lobe + 1.);
}

// 
/***** FXAA 2.0 by Nvidia *****/
vec4 FXAAPass(ivec2 tc)
{
    vec3 rgbNW = TEXEL_FETCH_OFFSET(screenCopyTex, tc, 0, ivec2(-1, -1)).rgb;
	vec3 rgbNE = TEXEL_FETCH_OFFSET(screenCopyTex, tc, 0, ivec2( 1, -1)).rgb;
	vec4 rgbaM = TEXEL_FETCH_OFFSET(screenCopyTex, tc, 0, ivec2( 0,  0));
	vec3 rgbSW = TEXEL_FETCH_OFFSET(screenCopyTex, tc, 0, ivec2(-1,  1)).rgb;
	vec3 rgbSE = TEXEL_FETCH_OFFSET(screenCopyTex, tc, 0, ivec2( 1,  1)).rgb;
    vec3 rgbM   = rgbaM.xyz;
    float opacity = rgbaM.w; 

    vec3 luma = vec3(0.299, 0.587, 0.114);

    float lumaNW = dot(rgbNW, luma);
    float lumaNE = dot(rgbNE, luma);
    float lumaSW = dot(rgbSW, luma);
    float lumaSE = dot(rgbSE, luma);
    float lumaM  = dot(rgbM,  luma);

    float lumaMin = min(lumaM, min(min(lumaNW, lumaNE), min(lumaSW, lumaSE)));
    float lumaMax = max(lumaM, max(max(lumaNW, lumaNE), max(lumaSW, lumaSE)));

    vec2 dir; 
    dir.x = -((lumaNW + lumaNE) - (lumaSW + lumaSE));
    dir.y =  ((lumaNW + lumaSW) - (lumaNE + lumaSE));

    float dirReduce = max(
        (lumaNW + lumaNE + lumaSW + lumaSE) * (0.25 * FXAA_REDUCE_MUL),
        FXAA_REDUCE_MIN);

    float rcpDirMin = 1.0/(min(abs(dir.x), abs(dir.y)) + dirReduce);

    dir = min(vec2( FXAA_SPAN_MAX,  FXAA_SPAN_MAX),
          max(vec2(-FXAA_SPAN_MAX, -FXAA_SPAN_MAX),
          dir * rcpDirMin)) * u_inverseViewportSize.xy;

    vec3 rgbA = 0.5 * (
        texture2D(screenCopyTex, gl_FragCoord.xy  * u_inverseViewportSize + dir * (1.0/3.0 - 0.5)).xyz +
        texture2D(screenCopyTex, gl_FragCoord.xy  * u_inverseViewportSize + dir * (2.0/3.0 - 0.5)).xyz);
    vec3 rgbB = rgbA * 0.5 + 0.25 * (
        texture2D(screenCopyTex, gl_FragCoord.xy  * u_inverseViewportSize + dir * -0.5).xyz +
        texture2D(screenCopyTex, gl_FragCoord.xy  * u_inverseViewportSize + dir * 0.5).xyz);

    float lumaB = dot(rgbB, luma);
    vec4 outColor;
    if ((lumaB < lumaMin) || (lumaB > lumaMax))
        outColor = vec4(rgbA, opacity);
    else
        outColor = vec4(rgbB, opacity);
    
    return outColor;
}



void main() {
    
    // Set up constants
    float con;
    FsrRcasCon(con,sharpness);

    // Perform RCAS pass
    vec3 col2 = FsrRcasF(ivec2(gl_FragCoord.xy), con);

    // Perform FXAA pass
	vec4 col = FXAAPass(ivec2(gl_FragCoord.xy));

	// Blend the two passes
    vec3 finalColor = mix(col.xyz, col2, blend_factor);	

    // Output to screen
    fragColor = vec4(finalColor, 1.0);

}
]]

-----------------------------------------------------------------
-- Global Variables
-----------------------------------------------------------------

local LuaShader = VFS.Include(luaShaderDir.."LuaShader.lua")

local vsx, vsy, vpx, vpy
local screenCopyTex
local fsrShader

local fullTexQuad

-----------------------------------------------------------------
-- Local Functions
-----------------------------------------------------------------


-----------------------------------------------------------------
-- Widget Functions
-----------------------------------------------------------------

local function UpdateShader()
	fsrShader:ActivateWith(function()
		fsrShader:SetUniform("sharpness", SHARPNESS)
		fsrShader:SetUniform("blend_factor", blend_factor)
        fsrShader:SetUniform("u_inverseViewportSize", 1.0 / vsx, 1.0 / vsy)
	end)
end

function widget:Initialize()

	if gl.CreateShader == nil then
		Spring.Echo("FSR: createshader not supported, removing")
		widgetHandler:RemoveWidget()
		return
	end

	-- disables CAS widget
	widgetHandler:DisableWidget('Contrast Adaptive Sharpen')


	vsx, vsy, vpx, vpy = Spring.GetViewGeometry()

	local commonTexOpts = {
		target = GL_TEXTURE_2D,
		border = false,
		min_filter = GL.NEAREST,
		mag_filter = GL.NEAREST,

		wrap_s = GL.CLAMP_TO_EDGE,
		wrap_t = GL.CLAMP_TO_EDGE,
	}

	commonTexOpts.format = GL_RGBA8
	--screenCopyTex = gl.CreateTexture(vsx, vsy, commonTexOpts)

    fsrShader = LuaShader({
		vertex = vsFSR,
		fragment = fsFSR,
		uniformInt = {
			screenCopyTex = 0,
		},
	}, ": FidelityFX Supersampling Resolution (FSR)")

	local shaderCompiled = fsrShader:Initialize()
	if not shaderCompiled then
			Spring.Echo("Failed to compile FSR, removing widget")
			widgetHandler:RemoveWidget()
			return
	end

	UpdateShader()

	fullTexQuad = gl.GetVAO()
	if fullTexQuad == nil then
		widgetHandler:RemoveWidget() --no fallback for potatoes
		return
	end

	WG.fsr = {}
	WG.fsr.setSharpness = function(value)
		SHARPNESS = value
		UpdateShader()
	end
	WG.fsr.getSharpness = function(value)
		return SHARPNESS
	end

end

function widget:Shutdown()
	--gl.DeleteTexture(screenCopyTex)
	if fsrShader then
		fsrShader:Finalize()
	end
	if fullTexQuad then
		fullTexQuad:Delete()
	end
	widgetHandler:EnableWidget('Contrast Adaptive Sharpen')
end

function widget:ViewResize()
	widget:Shutdown()
	widget:Initialize()
end

function widget:DrawScreenEffects()
	--glCopyToTexture(screenCopyTex, 0, 0, vpx, vpy, vsx, vsy)
	if WG['screencopymanager'] and WG['screencopymanager'].GetScreenCopy then
		screenCopyTex = WG['screencopymanager'].GetScreenCopy()
	else
		--glCopyToTexture(screenCopyTex, 0, 0, vpx, vpy, vsx, vsy)
		Spring.Echo("Missing Screencopy Manager, exiting",  WG['screencopymanager'] )
		widgetHandler:RemoveWidget()
		return false
	end
	if screenCopyTex == nil then return end
	glTexture(0, screenCopyTex)
	glBlending(false)
	fsrShader:Activate()
	fullTexQuad:DrawArrays(GL.TRIANGLES, 3)
	fsrShader:Deactivate()
	glBlending(true)
	glTexture(0, false)
end

function widget:GetConfigData(data)
	return {
		version = version,
		SHARPNESS = SHARPNESS,
		blend_factor = blend_factor
	}
end

function widget:SetConfigData(data)
	if data.SHARPNESS ~= nil and data.version ~= nil and data.blend_factor ~= nil and data.version == version then
		SHARPNESS = data.SHARPNESS
		blend_factor = data.blend_factor
	end
end